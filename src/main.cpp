/*
 * Copyright (c) 2023 Donatas Mockus.
 */
#include <Parser/Parser.h>
#include <iostream>
#include <fstream>
#include <chrono>
#include <libs/Println.h>
#include <Tokeniser/Tokeniser.h>
#include "Codegen/x86_64_linux/ProgramGenerator.h"
#include "libs/Error.h"
#include <Utils/Flags.h>
#include "libs/argparse.hpp"

using sys_clock = std::chrono::system_clock;
using seconds = std::chrono::duration<double>;

int main(int argc, const char** argv)
{
	argparse::ArgumentParser program("alxLang compiler", "0.0.3");
	program.add_description("A lexer, parser, and direct-to-asm compiler "
							"for alxLang - yet another general purpose programming language.");
	
	program.add_argument("-O0")
		.implicit_value(true)
		.default_value(true)
		.help("Turn off all optimisations");

	program.add_argument("-d", "--dump-ast")
		.default_value(false)
		.implicit_value(true).help(
			"Display the abstract syntax tree generated by the parser.");
	
	program.add_argument("-a", "--asm")
		.default_value(false)
		.implicit_value(true)
		.help("Output assembly to the console.");

	program.add_argument("-mno-red-zone")
		.default_value(false)
		.implicit_value(true); // FIXME: Make this false
	program.add_argument("filename");

	try
	{
		program.parse_args(argc, argv);
	}
	catch (std::runtime_error& err)
	{
		alx::println(alx::Colour::LightRed, "{}", err.what());
		return 1;
	}

	auto programName = program.get<std::string>("filename");
	alx::println("Parsing {}", programName);
	std::string sourceBuffer;
	{
		auto ss = std::ostringstream{};
		std::ifstream input(programName);
		if (!input.is_open())
		{
			alx::error("File {} not found!", programName);
			return EXIT_FAILURE;
		}
		ss << input.rdbuf();
		sourceBuffer = ss.str();
		input.close();
	}
	if (sourceBuffer.length() <= 0)
		return 0;

	const auto start = sys_clock::now();
	alx::Tokeniser tokeniser(sourceBuffer);
	auto tokens = tokeniser.Tokenise();

	{
		const seconds duration = sys_clock::now() - start;
		alx::println(alx::Colour::LightGreen, "Tokenised in {}ms", duration.count() * 1000);
	}
	const auto parseStart = sys_clock::now();

	alx::Parser parser(tokens);
	auto ast = parser.Parse();

	{
		const seconds duration = sys_clock::now() - parseStart;
		alx::println(alx::Colour::LightGreen, "Built AST in {}ms", duration.count() * 1000);
	}

	const auto generateStart = sys_clock::now();

	alx::ProgramGenerator generator(ast->Children(), alx::ResolveFlags(program));

	try
	{
		auto nasm = generator.Generate();
	}
	catch (std::runtime_error&)
	{
		alx::println(alx::Colour::LightRed, "Something went wrong when generating assembly. AST:");
		ast->PrintNode(0);
		return 1;
	}

	{
		const seconds duration = sys_clock::now() - generateStart;
		const seconds totalDuration = sys_clock::now() - start;
		alx::println(alx::Colour::LightGreen, "Compiled assembly in {}ms", duration.count() * 1000);
		alx::println(alx::Colour::LightGreen, "Total compilation time in {}ms", totalDuration.count() * 1000);
	}
	if (program.get<bool>("-d"))
	{
		alx::println();
		ast->PrintNode(0);
	}
	if (program.get<bool>("--asm"))
	{
		alx::println();
		alx::println(alx::ProgramGenerator::FormatAsm(generator.Asm()));
	}

	// nasm -f elf64 comp.asm -o comp.o && ld comp.o -o comp
}